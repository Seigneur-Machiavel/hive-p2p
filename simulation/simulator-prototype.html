<!DOCTYPE html>
<html>

<head>
	<title>P2P Network Visualization</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
	<link rel="stylesheet" href="./simulation/p2p_simulator.css">
</head>

<body>
	<div id="peersList"></div>
	<div id="simulationSettings">
		<h3>Simulation Settings</h3>
		<div>
			<label for="publicPeersCount">Public:</label>
			<input type="number" id="publicPeersCount" value="2">
		</div>
		<div>
			<label for="peersCount">Standard:</label>
			<input type="number" id="peersCount" value="5">
		</div>
		<button id="startSimulation">Start</button>
	</div>
	<div id="tooltip"></div>
	<div id="networkCanvas"></div>

	<script type="module">
		const config = {
			autoSelectCurrentPeerCategory: 'standard', // 'public' | 'standard' | false
			nodeRadius: 20,
			attraction: .001, // .001
			repulsion: 50000, // 50000
			damping: .02, // .95,
			centerForce: .0005, // .0005
			minDistance: {
				both_public: 1000,
				public: 500,
				standard: 100
			},
			maxVelocity: .5 // 1
		};
		const colors = {
			currentPeer: '#FFD700', // yellow
			hoveredPeer: '#FF4500', // orange red
			connectedPeerNeighbour: '#4CAF50', // green
			connectingPeerNeighbour: '#c1e6c1', // light green
			knownPeer: '#7d7d7d', // gray
			nodeBorder: '#272727', // dark gray
			publicNodeBorder: '#ffffff', // white

			connection: '#666666', // dark gray
			//currentPeerConnection: '#dec852', // light yellow
			currentPeerConnection: '#4CAF50', // green
			background: '#1a1a1a' // dark background
		};
		window.networkCanvasConfig = config; // Expose config globally for p5.js

		// Global variables
		const canvasDims = { width: 800, height: 600 };
		let p5Instance = null;
		let networkMap = {};
		let positions = new Map();
		let velocities = new Map();
		let currentPeerId = null;
		let hoveredNodeId = null;
		let nodes = {};
		/** @type {Object<string, Array<string>>} key: peerId, value: Array<peerId> */
		let connectionsByPeer = {};
		let connections = {};
		let lastPeerInfo = null;

		const ws = new WebSocket('ws://localhost:3000');
		setInterval(() => { if (currentPeerId) ws.send(JSON.stringify({ type: 'getPeerInfo', peerId: currentPeerId })) }, 1000);
		setInterval(() => { ws.send(JSON.stringify({ type: 'getPeersIds' })) }, 5000);
		document.getElementById('startSimulation').onclick = () => {
			resetNetwork();
			ws.send(JSON.stringify({ type: 'start', settings: getSimulatorSettings() }));
		};

		ws.onmessage = (event) => {
			const msg = JSON.parse(event.data);
			if (msg.type === 'settings') handleSettings(msg.data);
			if (msg.type === 'peersIds') updatePeersList(msg.data);
			if (msg.type === 'peerInfo') updateNetworkFromPeerInfo(msg.data);
		};

		function setSelectedPeer(peerId) {
			if (!peerId) return;
			if (currentPeerId !== peerId) resetNetwork();
			currentPeerId = peerId;
			for (const peerItem of document.querySelectorAll(`#peersList div[data-peer-id]`))
				if (peerItem.dataset.peerId === peerId) peerItem.classList.add('selected');
				else peerItem.classList.remove('selected');
		}
		function handleSettings(settings) {
			if (settings.publicPeersCount) document.getElementById('publicPeersCount').value = settings.publicPeersCount;
			if (settings.peersCount) document.getElementById('peersCount').value = settings.peersCount;
			if (settings.autoStart) ws.send(JSON.stringify({ type: 'getPeersIds' }));
		}
		function getSimulatorSettings() {
			return {
				publicPeersCount: parseInt(document.getElementById('publicPeersCount').value),
				peersCount: parseInt(document.getElementById('peersCount').value)
			};
		}
		function updatePeersList(peersData) {
			const peersList = document.getElementById('peersList');
			peersList.innerHTML = '<h3>Peers list</h3>';

			for (const [category, peerIds] of Object.entries(peersData)) {
				for (const peerId of peerIds) {
					const peerItem = document.createElement('div');
					peerItem.dataset.peerId = peerId;
					peerItem.textContent = peerId;
					peerItem.onclick = () => {
						setSelectedPeer(peerId);
						ws.send(JSON.stringify({ type: 'getPeerInfo', peerId }));
					};
					peersList.appendChild(peerItem);
				}
				if (currentPeerId || peerIds.length === 0) continue; // Skip if current peer is set or no peers in this category
				if (category === config.autoSelectCurrentPeerCategory) setSelectedPeer(peerIds[0]);
			}

			if (currentPeerId) setSelectedPeer(currentPeerId); // Auto-select current peer
		}
		function resetNetwork() {
			positions.clear();
			velocities.clear();
			nodes = {};
			networkMap = {};
			connections = {};
		}
		function updateNetworkFromPeerInfo(peerInfo) {
			if (!peerInfo) return;
			lastPeerInfo = peerInfo;

			const newlyUpdated = {};
			function digestPeerUpdate(id, status) {
				if (!positions.has(id)) {
					if (id === peerInfo.id) positions.set(id, { x: canvasDims.width / 2, y: canvasDims.height / 2 });
					else positions.set(id, { x: canvasDims.width / 2 + (Math.random() - 0.5) * 200, y: canvasDims.height / 2 + (Math.random() - 0.5) * 200 });
					velocities.set(id, { x: 0, y: 0 });
				}
				const isPublic = id.startsWith('public_');
				nodes[id] = { status: id === peerInfo.id ? 'current' : status, neighbours: getNeighbours(id), isPublic };
				newlyUpdated[id] = true;
			}

			for (const [id, peer] of Object.entries(peerInfo.known)) digestPeerUpdate(id, 'known');
			for (const id of peerInfo.connecting) digestPeerUpdate(id, 'connecting');
			for (const id of peerInfo.connected) digestPeerUpdate(id, 'connected');
			if (peerInfo.id) digestPeerUpdate(peerInfo.id, 'current'); // ensure current peer is updated

			// filter absent nodes
			for (const id of Object.keys(nodes))
				if (!newlyUpdated[id]) {
					delete nodes[id];
					positions.delete(id);
					velocities.delete(id);
				}

			// Create connections
			connections = {};
			connectionsByPeer = {};
			for (const [id, node] of Object.entries(nodes)) connectionsByPeer[id] = node.neighbours || {};
			for (const [id, node] of Object.entries(nodes))
				for (const neighbourId of node.neighbours) {
					const conStr = `${id}:${neighbourId}`;
					const conStrRev = `${neighbourId}:${id}`;
					if (connections[conStr] !== undefined || connections[conStrRev] !== undefined) continue;
					connections[conStr] = false; // "false" means not drawn
				}

			console.log(`Updated network map: ${Object.keys(nodes).length} nodes | ${Object.keys(connections).length} connections`);
		}
		function getNeighbours(peerId, peerInfo = lastPeerInfo) {
			if (peerId === peerInfo.id) return peerInfo.connected;
			const knownPeer = peerInfo.known[peerId];
			return knownPeer ? Object.keys(knownPeer.neighbours || {}) : [];
		}

		const sketch = (p) => { // p5.js sketch using instance mode
			p.setup = () => {
				canvasDims.width = window.innerWidth - 40;
				canvasDims.height = window.innerHeight - 40;
				const canvas = p.createCanvas(canvasDims.width, canvasDims.height);
				canvas.parent('networkCanvas');
				canvas.canvas.addEventListener('mousemove', handleMouseMove);
				canvas.canvas.addEventListener('mouseleave', hideTooltip);
				canvas.canvas.addEventListener('click', () => setSelectedPeer(hoveredNodeId));
			};
			p.draw = () => drawNetwork();
			p.windowResized = () => {
				p.resizeCanvas(window.innerWidth - 40, window.innerHeight - 40);
				canvasDims.width = window.innerWidth - 40;
				canvasDims.height = window.innerHeight - 40;
			};
		};

		function drawNetwork() {
			if (!p5Instance) return;
			p5Instance.background(colors.background);
			if (Object.keys(nodes).length === 0) return;

			updatePhysics();

			// Draw connections
			const maxLowInterestConnectionsLines = 0;
			let connectionsDrawn = 0;
			for (const connStr of Object.keys(connections).sort(() => Math.random() - 0.5)) {
				const [from, to] = connStr.split(':');
				const fromPos = positions.get(from);
				const toPos = positions.get(to);
				if (!fromPos || !toPos) continue;
				
				let strokeColor = colors.connection;
				const isCurrentPeer = from === currentPeerId || to === currentPeerId;
				const isHoveredPeer = from === hoveredNodeId || to === hoveredNodeId;
				if (isCurrentPeer) strokeColor = colors.currentPeerConnection;
				if (isHoveredPeer) strokeColor = colors.hoveredPeer;
				if (isCurrentPeer && isHoveredPeer) strokeColor = colors.currentPeer;
				const isLowInterest = strokeColor === colors.connection;
				if (isLowInterest && connectionsDrawn >= maxLowInterestConnectionsLines) continue;

				p5Instance.strokeWeight(2);
				p5Instance.stroke(strokeColor);
				p5Instance.line(fromPos.x, fromPos.y, toPos.x, toPos.y);
				connections[connStr] = true; // Mark as drawn
				connectionsDrawn++;
			};

			// Draw nodes
			for (const [id, node] of Object.entries(nodes)) {
				const pos = positions.get(id);
				if (!pos) return;

				// Node color based on status
				let nodeColor = colors.knownPeer;
				if (node.status === 'current') nodeColor = colors.currentPeer;
				else if (node.status === 'connected') nodeColor = colors.connectedPeerNeighbour;
				else if (node.status === 'connecting') nodeColor = colors.connectingPeerNeighbour;

				let strokeColor = node.isPublic ? colors.publicNodeBorder : colors.nodeBorder;
				if (id === hoveredNodeId) strokeColor = colors.hoveredPeer;
				p5Instance.fill(nodeColor);
				p5Instance.stroke(strokeColor);
				p5Instance.strokeWeight(node.isPublic ? 3 : 2);
				p5Instance.ellipse(pos.x, pos.y, config.nodeRadius * 2);

				// Node label
				let isImportant = node.status === 'connected' || id === hoveredNodeId || id === currentPeerId;
				if (getNeighbours(id).includes(hoveredNodeId)) isImportant = true;
				if (!isImportant) continue;

				p5Instance.fill(255);
				p5Instance.noStroke();
				p5Instance.textAlign(p5Instance.CENTER, p5Instance.CENTER);
				p5Instance.textSize(10);
				p5Instance.text(id.substring(0, 8), pos.x, pos.y + config.nodeRadius + 15);
			};
		}

		function updatePhysics() {
			for (const [id, node] of Object.entries(nodes)) { // Apply forces
				const pos = positions.get(id);
				const vel = velocities.get(id);
				if (!pos || !vel) continue;

				let fx = 0, fy = 0;

				// Repulsion between all nodes
				for (const [otherNodeId, otherNode] of Object.entries(nodes)) {
					if (id === otherNodeId) continue;

					const otherPos = positions.get(otherNodeId);
					if (!otherPos) continue;
					const dx = pos.x - otherPos.x;
					const dy = pos.y - otherPos.y;
					const distance = Math.sqrt(dx * dx + dy * dy);

					let minDistance = config.minDistance.standard;
					if (node.isPublic) minDistance -= config.minDistance.public;
					if (node.isPublic && otherNode.isPublic) minDistance += config.minDistance.both_public;
					if (distance >= Math.max(minDistance, config.minDistance.standard)) continue;

					const force = config.repulsion / (distance * distance + 1);
					fx += (dx / distance) * force;
					fy += (dy / distance) * force;
				};

				// Attraction along connections
				for (const conn of Object.keys(connections)) {
					const [peerId1, peerId2] = conn.split(':');
					const otherId = peerId1 === id ? peerId2 : peerId1;
					const otherPos = positions.get(otherId);
					if (!otherPos) continue;

					const dx = otherPos.x - pos.x;
					const dy = otherPos.y - pos.y;
					const distance = Math.sqrt(dx * dx + dy * dy);
					const force = distance * config.attraction;
					fx += (dx / distance) * force;
					fy += (dy / distance) * force;
				};

				// Center force
				const centerX = canvasDims.width / 2;
				const centerY = canvasDims.height / 2;
				fx += (centerX - pos.x) * config.centerForce;
				fy += (centerY - pos.y) * config.centerForce;

				// Update velocity
				vel.x = (vel.x + fx) * config.damping;
				vel.y = (vel.y + fy) * config.damping;

				// Limit velocity
				const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
				if (speed > config.maxVelocity) {
					vel.x = (vel.x / speed) * config.maxVelocity;
					vel.y = (vel.y / speed) * config.maxVelocity;
				}

				// Update position
				pos.x += vel.x;
				pos.y += vel.y;

				// Keep in bounds
				pos.x = Math.max(config.nodeRadius, Math.min(canvasDims.width - config.nodeRadius, pos.x));
				pos.y = Math.max(config.nodeRadius, Math.min(canvasDims.height - config.nodeRadius, pos.y));
			};
		}

		function handleMouseMove(event) {
			const rect = event.target.getBoundingClientRect();
			const mouseX = event.clientX - rect.left;
			const mouseY = event.clientY - rect.top;
			for (const [id, node] of Object.entries(nodes)) {
				if (!positions.get(id)) continue;

				const { x, y } = positions.get(id);
				const distance = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
				if (distance > config.nodeRadius) continue;
				showTooltip(event.clientX, event.clientY, id, node);
				event.target.style.cursor = 'pointer';
				hoveredNodeId = id;
				return;
			}

			hideTooltip();
			hoveredNodeId = null;
			event.target.style.cursor = 'default';
		}

		function showTooltip(x, y, id, node) {
			const tooltip = document.getElementById('tooltip');
			const json = {
				Peer: id,
				Type: node.status,
				Neighbours: node.neighbours || 'None'
			}
			/*	<strong>Peer:</strong> ${id}
				<strong>Type:</strong> ${node.status}
				<strong>Neighbours:</strong> ${node.neighbours || 'None'}*/
			tooltip.innerHTML = `<pre>${JSON.stringify(json, null, 2)}</pre>`;

			tooltip.style.left = x + 10 + 'px';
			tooltip.style.top = y + 10 + 'px';
			tooltip.style.display = 'block';
		}

		function hideTooltip() {
			document.getElementById('tooltip').style.display = 'none';
		}

		p5Instance = new p5(sketch); // Initialize p5.js
	</script>
</body>

</html>